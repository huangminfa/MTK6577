/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.gallery3d.ui;

import com.android.gallery3d.R;
import com.android.gallery3d.app.GalleryActivity;
import com.android.gallery3d.common.Utils;
import com.android.gallery3d.data.Path;
import com.android.gallery3d.ui.PositionRepository.Position;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.RectF;
import android.os.Message;
import android.os.SystemClock;
import android.view.Display;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;

import com.android.gallery3d.util.DrmHelper;
import com.android.gallery3d.util.StereoHelper;
import com.android.gallery3d.util.MediatekFeature;
import com.android.gallery3d.util.MtkLog;

import android.app.Activity;

import com.mediatek.stereo3d.Stereo3DConvergence;


// Comments added by Mediatek Inc.
// TileImageViewAdapter connects PhotoDataAdapter (or SinglePhotoDataAdapter)
// and TileImageView. It stores the data that PhotoDataAdapter retrieved for it
// and provides them to TileImageView.
// As Mediate adds new features to Google default feature, such as Drm support
// and Stereo Display support, modifications are inevitable.

// Before stereo full images (full images for left eye and right eye) are added,
// stereo thumbnails (thumbnails for left eye and right eye) are added in the
// TileImageView for simplicity: besides backup image and full image, first image
// thumbnail and second image thumbanil are created and displayed when needed.
// When stereo full images are added, it is almost impossible to add them in
// the TileImageView without huge modification because allocating and decoding
// tiles is a complex task. It seems the only easy solution is to create two extra
// TileImageView(s), one for first image and one for second image. Each image can
// has a backup image and full image.
// The reason why we added two extra TileImageView is that: for normal image
// that is displayed as 3D image, corresponding algorithm will generate left
// and right images. Original image, left image and right image will be store
// in unique TileImageView, so 3 TileImageView is needed.
// For real stere image, we regard its left frame as its 2D image, and display
// left frame when user want to see 2D version of the original image. Actually
// only two TileImageView is need, but we always create three for simplicity.
// (Will there be one day that the 2D version of original image is generated by
// algorithm ?)
// The three TileImageView can be distinguished by its member STERE_INDEX defined
// in StereoHelper. 
// 
// As there are 3 TileImageViews, but only 1 PositionController, we would 
// coordinate behavior the 3 TileImageViews to avail the single PositionController
// For simplicity, we call TileImageView whose stereo index is none T0. 
// the one whose stereo index is first is named as T1, 
// the one whose stereo index is second is named as T2.
// T0 is the default TileImageView that is created by Google.
// T1 & T2 are added by Mediatek for stereo display feature.
// The problem we should resolve is that how to coordinate T0, T1 and T2 for all
// kinds of images {including normal image, true 3d image, and 3d image converted
// by algorithm from nor image} and all kinds of user interaction {including
// 2d/3d mode switch, zooming, sliding and so on}
// We choose T0 as the primary one, and adjust others to "match" T0.
// T0 displays normal image and first frame of true 3d image.
// The first frame is displayed as default Gallery does for normal image.
//
// 3d image is tricky: image displayed is only a portion of original size.
// There are two process: auto convergence and manual convergence.
// Auto convergence is to crop a region out of each frame which the algorithm
// believe is a good stereo pair: the central object is aligned and background is
// different. this would create a logic new image A' (we name original frame as A).
// By default, auto convergence undertakes secretly (user may never notice this
// unless he compares the image displayed on our phone and the image displayed on
// PC or other device). A' is logically smaller than A, but A' is often bigger than
// screen size. When image is displayed in stereo mode, we replace A' with A, 
// making A' center of A. That is: A' is place on the center of position that A once
// occupied, without zooming.
// Then user can fine tuning convergence manualy (We call this small feature Manul
// convergence): left or right portion will be further cutted, resulting A''. A'' 
// is displayed instead of A'.
//
// The trick we use is: 
// 1, set info of A to PositionController, making user interaction control follow
//    almost unchanged. PositionController will never know the existence of A', A''
// 2, When display in 2D mode, simply disply A as usual
// 3, When display in 3D mode, place A' in the center of A (!!! not to fit screen
//    size) trime A' to create logical A'', place A'' in the center of A', zoom
//    ratio remains unchanged.
// Following the above rules, A, A' and A'' will have a fixed relationship in
// position, and be controlled by single PositionController.
//
// The cropping of A to form A' and triming of A' to form A'' is done by rendering,
// not by real Bitmap decoding or manipulation. This can make sure that tuning
// convergence take effect on the fly.
// The cropping and triming is implemented by glScissor(), making region un-needed
// never be drawn to the screen.

public class PhotoView extends GLView {
    @SuppressWarnings("unused")
    private static final String TAG = "PhotoView";

    public static final int INVALID_SIZE = -1;

    private static final int MSG_TRANSITION_COMPLETE = 1;
    private static final int MSG_SHOW_LOADING = 2;

    private static final long DELAY_SHOW_LOADING = 250; // 250ms;

    private static final int TRANS_NONE = 0;
    private static final int TRANS_SWITCH_NEXT = 3;
    private static final int TRANS_SWITCH_PREVIOUS = 4;

    public static final int TRANS_SLIDE_IN_RIGHT = 1;
    public static final int TRANS_SLIDE_IN_LEFT = 2;
    public static final int TRANS_OPEN_ANIMATION = 5;

    private static final int LOADING_INIT = 0;
    private static final int LOADING_TIMEOUT = 1;
    private static final int LOADING_COMPLETE = 2;
    private static final int LOADING_FAIL = 3;

    private static final int ENTRY_PREVIOUS = 0;
    private static final int ENTRY_NEXT = 1;

    private static final int IMAGE_GAP = 96;
    private static final int SWITCH_THRESHOLD = 256;
    private static final float SWIPE_THRESHOLD = 300f;

    private static final float DEFAULT_TEXT_SIZE = 20;

    private static final boolean mIsDrmSupported = 
                                          MediatekFeature.isDrmSupported();
    private static final boolean mIsStereoDisplaySupported = 
                        MediatekFeature.isStereoDisplaySupported();
    private static final boolean mIsStereoConvergenceSupported =
                        MediatekFeature.isStereoConvergenceSupported();

    public interface StereoModeChangeListener {
        public void onChangedToStereoMode(boolean stereoMode);
    }

    private StereoModeChangeListener mStereoModeChangeListener;

    public void setStereoModeChangeListener(StereoModeChangeListener stereoListener) {
        mStereoModeChangeListener = stereoListener;
    }

    public interface PhotoTapListener {
        public void onSingleTapUp(int x, int y);
    }

    // the previous/next image entries
    private final ScreenNailEntry mScreenNails[] = new ScreenNailEntry[2];

    private final ScaleGestureDetector mScaleDetector;
    private final GestureDetector mGestureDetector;
    private final DownUpDetector mDownUpDetector;

    private PhotoTapListener mPhotoTapListener;

    private final PositionController mPositionController;

    private Model mModel;
    private StringTexture mLoadingText;
    private StringTexture mNoThumbnailText;
    private int mTransitionMode = TRANS_NONE;
    private final TileImageView mTileView;
    private EdgeView mEdgeView;
    private Texture mVideoPlayIcon;

    private boolean mShowVideoPlayIcon;
    private ProgressSpinner mLoadingSpinner;

    //added to support mpo
    private boolean mShowMpoViewIcon;
    private Texture mMpoViewIcon;
    //added to support stereo display
    private boolean mStereoMode;
    private boolean mStereoModeAllowed;
    private boolean mStereoModeWhenScaled;
    private boolean mAtStereoMaxScaleWhenScaled;
    private TileImageView mFirstTileView;
    private TileImageView mSecondTileView;

    private SynchronizedHandler mHandler;

    private int mLoadingState = LOADING_COMPLETE;

    private int mImageRotation;
    private int displayWidth;
    private int displayHeight;

    private Path mOpenedItemPath;
    private GalleryActivity mActivity;
    
    // for stereo3D manual convergence
    private boolean mConvMode = false;

    public PhotoView(GalleryActivity activity) {
        mActivity = activity;
        mTileView = new TileImageView(activity);
        addComponent(mTileView);

        if (mIsStereoDisplaySupported) {
            mFirstTileView = new TileImageView(activity);
            mFirstTileView.setStereoIndex(StereoHelper.STEREO_INDEX_FIRST);
            addComponent(mFirstTileView);
            mSecondTileView = new TileImageView(activity);
            mSecondTileView.setStereoIndex(StereoHelper.STEREO_INDEX_SECOND);
            addComponent(mSecondTileView);
        }

        Context context = activity.getAndroidContext();
        mEdgeView = new EdgeView(context);
        addComponent(mEdgeView);
        mLoadingSpinner = new ProgressSpinner(context);
        mLoadingText = StringTexture.newInstance(
                context.getString(R.string.loading),
                DEFAULT_TEXT_SIZE, Color.WHITE);
        mNoThumbnailText = StringTexture.newInstance(
                context.getString(R.string.no_thumbnail),
                DEFAULT_TEXT_SIZE, Color.WHITE);

        mHandler = new SynchronizedHandler(activity.getGLRoot()) {
            @Override
            public void handleMessage(Message message) {
                switch (message.what) {
                    case MSG_TRANSITION_COMPLETE: {
                        onTransitionComplete();
                        break;
                    }
                    case MSG_SHOW_LOADING: {
                        if (mLoadingState == LOADING_INIT) {
                            // We don't need the opening animation
                            mOpenedItemPath = null;

                            mLoadingSpinner.startAnimation();
                            mLoadingState = LOADING_TIMEOUT;
                            invalidate();
                        }
                        break;
                    }
                    default: throw new AssertionError(message.what);
                }
            }
        };

        mGestureDetector = new GestureDetector(context,
                new MyGestureListener(), null, true /* ignoreMultitouch */);
        mScaleDetector = new ScaleGestureDetector(context, new MyScaleListener());
        mDownUpDetector = new DownUpDetector(new MyDownUpListener());

        for (int i = 0, n = mScreenNails.length; i < n; ++i) {
            mScreenNails[i] = new ScreenNailEntry();
        }

        mPositionController = new PositionController(this, context, mEdgeView);
        mVideoPlayIcon = new ResourceTexture(context, R.drawable.ic_control_play);

        if (MediatekFeature.isMpoSupported()) {
            //load mpo view icon
            mMpoViewIcon = new ResourceTexture(context, R.drawable.icon_mav_overlay);
        }
        Display display = ((Activity)mActivity).getWindowManager().getDefaultDisplay();
        displayWidth = display.getWidth();
        displayHeight = display.getHeight();
    }


    public void setModel(Model model) {
        if (mModel == model) return;
        mModel = model;
        mTileView.setModel(model);
        if (mIsStereoDisplaySupported) {
            mFirstTileView.setModel(model);
            mSecondTileView.setModel(model);
        }
        if (model != null) notifyOnNewImage();
    }

    public void setPhotoTapListener(PhotoTapListener listener) {
        mPhotoTapListener = listener;
    }

    private boolean setTileViewPosition(int centerX, int centerY, float scale) {
        boolean changed = false;
        changed = setTileViewPosition(mTileView, centerX, centerY, scale);
        if (mIsStereoDisplaySupported) {
            changed = setTileViewPosition(mFirstTileView,centerX, centerY, 
                                          scale) || changed;
            changed = setTileViewPosition(mSecondTileView,centerX, centerY, 
                                          scale) || changed;
        }
        return changed;
    }

    private boolean setTileViewPosition(TileImageView t,int centerX,
                                        int centerY, float scale) {
        int inverseX = mPositionController.getImageWidth() - centerX;
        int inverseY = mPositionController.getImageHeight() - centerY;
        int rotation = mImageRotation;
        switch (rotation) {
            case 0: return t.setPosition(centerX, centerY, scale, 0);
            case 90: return t.setPosition(centerY, inverseX, scale, 90);
            case 180: return t.setPosition(inverseX, inverseY, scale, 180);
            case 270: return t.setPosition(inverseY, centerX, scale, 270);
            default: throw new IllegalArgumentException(String.valueOf(rotation));
        }
    }

    public void setPosition(int centerX, int centerY, float scale) {
        if (MtkLog.DBG) {
            MtkLog.d(TAG,  "setPosition: (" + centerX + ", " + centerY + ", " + scale + ")");
        }
        if (setTileViewPosition(centerX, centerY, scale)) {
            layoutScreenNails();
        }
    }

    private void updateScreenNailEntry(int which, ImageData data) {
        if (mTransitionMode == TRANS_SWITCH_NEXT
                || mTransitionMode == TRANS_SWITCH_PREVIOUS) {
            // ignore screen nail updating during switching
            return;
        }
        ScreenNailEntry entry = mScreenNails[which];
        if (data == null) {
            entry.set(false, null, 0);
        } else {
            //add mediate feature support
            updateScreenNailEntry(entry, data);

            if (mIsDrmSupported) {
                entry.set(true, data.bitmap, data.rotation,
                          data.showDrmMicroThumb, data.subType);
            } else {
                entry.set(true, data.bitmap, data.rotation);
            }
        }
    }

    private void updateScreenNailEntry(ScreenNailEntry entry, ImageData data) {
        if (null == entry || null == data) return;
        if (MediatekFeature.isCMCC()) { 
            entry.originWidth = data.originWidth;
            entry.originHeight = data.originHeight;
            entry.suggestFullScreen = data.suggestFullScreen;
            return;
        }
    }

    public boolean mAcEnabled = true;
    public void setAcEnabled(boolean acEnabled) {
        if (!mIsStereoDisplaySupported) return;
        mAcEnabled = acEnabled;

        Log.i(TAG,"setAcEnabled:mAcEnabled="+mAcEnabled);
        if (mConvergenceProgress < 0 || mConvergenceProgress >= mCvgIndexNum) {
            Log.e(TAG,"setAcEnabled:invalid progress!!!");
        }

        mTileView.mAcEnabled = mAcEnabled;
        mTileView.setBackupPosition();
        mSecondTileView.mAcEnabled = mAcEnabled;
        mSecondTileView.setBackupPosition();
    }

    public int mStoredProgress = -1;
    public void setStoredProgress(int progress) {
        Log.v(TAG, "setStoredProgress:progress=" + progress);
        mStoredProgress = progress;
        if (mStoredProgress >= 0) {
            setConvergenceProgress(mStoredProgress);
        }
    }
    public int mConvergenceProgress = 0;
    public void setConvergenceProgress(int progress) {
        if (!mIsStereoDisplaySupported) return;
        mConvergenceProgress = progress;
        Log.i(TAG,"setConvergenceProgress:mConvergenceProgress="+mConvergenceProgress);

        if (mConvergenceProgress < 0 || mConvergenceProgress >= mCvgIndexNum) {
            Log.e(TAG,"setConvergenceProgress:invalid progress!!!");
            return;
        }

        //if there is no stereo convergence data, no bother to tune.
        if (null == mStereoConvergence) return;

        mTileView.mOffsetXRate = mLeftOffsetXRate[mConvergenceProgress];
        mTileView.mWidthRate = mWidthRate[mConvergenceProgress];
        mTileView.setBackupPosition();
        mSecondTileView.mOffsetXRate = mRightOffsetXRate[mConvergenceProgress];
        mSecondTileView.mWidthRate = mWidthRate[mConvergenceProgress];
        mSecondTileView.setBackupPosition();
    }

    public int mActiveFlags[];
    public static final int[] mConvergenceValues = {0, 10, 20, 30, 40, 50, 60, 70, 80};
    private static final int mSubIndexNum = 10;
    private static final int mCvgIndexNum = (9 - 1) * mSubIndexNum + 1;
    private float mLeftOffsetXRate[];
    private float mRightOffsetXRate[];
    private float mWidthRate[];

    private Stereo3DConvergence mStereoConvergence;

    private void retrievStereoConvergence() {
        if (!mIsStereoDisplaySupported) return;
        Log.d(TAG,"retrieveStereoConvergence()");
        Stereo3DConvergence stereoConvergence = mModel.getStereoConvergence();
        if (null == stereoConvergence) {
            Log.d(TAG,"retrievStereoConvergence:reset");
            resetStereoConvergence();
            return;
        } else if (mStereoConvergence == stereoConvergence) {
            Log.d(TAG,"retrievStereoConvergence:already retrieved!");
            return;
        }
        //we record the previous reslut
        mStereoConvergence = stereoConvergence;

        //we know that the convergence feature is only for truely 3D image
        //so we know that the TileImageViews affected is just mTileView and
        //mSecondTileView.
        Bitmap secondImage = mModel.getSecondImage();
        if (null == secondImage) return;
        int width = secondImage.getWidth();
        int height = secondImage.getHeight();
        int defaultPos = stereoConvergence.getDefaultPosition();
        mActiveFlags = stereoConvergence.getActiveFlags();
        //note, plan change, only show flag on the default position
        if (null == mActiveFlags) {
            Log.e(TAG, "retrievStereoConvergence:null active flags!");
            mActiveFlags = new int[mSubIndexNum];
        }
        for (int i = 0; i < mActiveFlags.length; i++) {
            mActiveFlags[i] = 0;
        }
        mActiveFlags[defaultPos] = 1;

        float lOffsetX = 0.0f;
        float rOffsetX = 0.0f;
        //to maximize image size that is to be displayed, we need to adjust
        float lNewOffsetX = 0.0f;
        float rNewOffsetX = 0.0f;
        float newCropW = 0.0f;//width - Math.max(lNewOffsetX, rNewOffsetX);

        // Note: can we reuse the below arrays? current design seams
        // low memory efficiency.
        if (null == mLeftOffsetXRate) {
            mLeftOffsetXRate = new float[mCvgIndexNum];
        }
        if (null == mRightOffsetXRate) {
            mRightOffsetXRate = new float[mCvgIndexNum];
        }
        if (null == mWidthRate) {
            mWidthRate = new float[mCvgIndexNum];
        }

        //inteplate original offsets
        int[] intervals = stereoConvergence.getCroppingIntervals(true);
        for (int i = 0; i < intervals.length; i++) {
            mLeftOffsetXRate[i * mSubIndexNum] = (float)intervals[i];
        }
        for (int i = 0; i < intervals.length - 1; i++) {
            //we fill the sub region with linear difference value
            LinearDifference(mLeftOffsetXRate, i * mSubIndexNum, (i + 1) * mSubIndexNum);
        }

        intervals = stereoConvergence.getCroppingIntervals(false);
        for (int i = 0; i < intervals.length; i++) {
            mRightOffsetXRate[i * mSubIndexNum] = (float)intervals[i];
        }
        for (int i = 0; i < intervals.length - 1; i++) {
            //we fill the sub region with linear difference value
            LinearDifference(mRightOffsetXRate, i * mSubIndexNum, (i + 1) * mSubIndexNum);
        }

        for (int i = 0; i < mWidthRate.length; i++) {
            //if (i != defaultPos * mSubIndexNum) continue;
            lOffsetX = mLeftOffsetXRate[i];
            rOffsetX = mRightOffsetXRate[i];

            //to maximize image size that is to be displayed, we need to adjust
            lNewOffsetX = lOffsetX - Math.min(lOffsetX, rOffsetX);
            rNewOffsetX = rOffsetX - Math.min(lOffsetX, rOffsetX);
            newCropW = width - Math.max(lNewOffsetX, rNewOffsetX);

            mWidthRate[i] = (float)newCropW / (float)width;
            mLeftOffsetXRate[i] = lNewOffsetX / (float)width;
            mRightOffsetXRate[i] = rNewOffsetX / (float)width;
        }

        //we record the previous reslut
        if (mStoredProgress < 0) {
            mConvergenceProgress = defaultPos * mSubIndexNum;
        } else {
            mConvergenceProgress = mStoredProgress;
        }

        float lOffsetY = (float)stereoConvergence.getOffsetY(true);
        float rOffsetY = (float)stereoConvergence.getOffsetY(false);
        float lNewOffsetY = lOffsetY - Math.min(lOffsetY, rOffsetY);
        float rNewOffsetY = rOffsetY - Math.min(lOffsetY, rOffsetY);
        float newCropH = (float)height - Math.max(lNewOffsetY, rNewOffsetY);

        mTileView.mOffsetYRate = lNewOffsetY/(float)height;
        mTileView.mHeightRate = newCropH/(float)height;

        mSecondTileView.mOffsetYRate = rNewOffsetY/(float)height;
        mSecondTileView.mHeightRate = mTileView.mHeightRate;

        setConvergenceProgress(mConvergenceProgress);
    }

    private void LinearDifference(float[] array, int startIndex, int endIndex) {
        if (null == array || startIndex < 0 || endIndex < startIndex) {
            Log.e(TAG,"LinearDifferece:invalid input params");
            return;
        }
        float startValue = array[startIndex];
        float endValue = array[endIndex];
        for (int i = startIndex + 1; i < endIndex; i++) {
            array[i] = (endValue - startValue) * (i - startIndex)
                       / (endIndex - startIndex) + array[startIndex];
        }
        return;
    }

    private void resetStereoConvergence() {
        if (!mIsStereoDisplaySupported) return;

        //reset auto convergence data
        mStereoConvergence = null;

        mTileView.mOffsetXRate = 0.0f;
        mTileView.mOffsetYRate = 0.0f;
        mTileView.mWidthRate = 1.0f;
        mTileView.mHeightRate = 1.0f;

        mSecondTileView.mOffsetXRate = 0.0f;
        mSecondTileView.mOffsetYRate = 0.0f;
        mSecondTileView.mWidthRate = 1.0f;
        mSecondTileView.mHeightRate = 1.0f;
    }

    // -1 previous, 0 current, 1 next
    public void notifyImageInvalidated(int which) {
        switch (which) {
            case -1: {
                updateScreenNailEntry(
                        ENTRY_PREVIOUS, mModel.getPreviousImage());
                layoutScreenNails();
                invalidate();
                break;
            }
            case 1: {
                updateScreenNailEntry(ENTRY_NEXT, mModel.getNextImage());
                layoutScreenNails();
                invalidate();
                break;
            }
            case 0: {
                // mImageWidth and mImageHeight will get updated
                mTileView.notifyModelInvalidated();
                //added for stereo display feature
                if (mIsStereoDisplaySupported) {
                    mFirstTileView.notifyModelInvalidated();
                    mSecondTileView.notifyModelInvalidated();
                    //retrieve auto convergence data if any
                    retrievStereoConvergence();
                }
                if (mIsDrmSupported) {
                    //check whether we should display a thumb as drm micro-thumb
                    mPositionController.setShowDrmMicroThumb(
                                               mModel.showDrmMicroThumb());
                }
                if (MediatekFeature.isCMCC()) {
                    if (mModel.getImageHeight() < displayHeight && mModel.getImageWidth() < displayWidth) {
                        mPositionController.setSuggestFullScreen(
                                               mModel.suggestFullScreen());
                    }
                }
                mImageRotation = mModel.getImageRotation();
                if (((mImageRotation / 90) & 1) == 0) {
                    mPositionController.setImageSize(
                            mTileView.mImageWidth, mTileView.mImageHeight);
                } else {
                    mPositionController.setImageSize(
                            mTileView.mImageHeight, mTileView.mImageWidth);
                }
                updateLoadingState();
                break;
            }
        }
    }

    private void updateLoadingState() {
        // Possible transitions of mLoadingState:
        //        INIT --> TIMEOUT, COMPLETE, FAIL
        //     TIMEOUT --> COMPLETE, FAIL, INIT
        //    COMPLETE --> INIT
        //        FAIL --> INIT
        if (mModel.getLevelCount() != 0 || mModel.getBackupImage() != null) {
            mHandler.removeMessages(MSG_SHOW_LOADING);
            mLoadingState = LOADING_COMPLETE;
        } else if (mModel.isFailedToLoad()) {
            mHandler.removeMessages(MSG_SHOW_LOADING);
            mLoadingState = LOADING_FAIL;
            // clear the open item path to avoid unnecessary animation for following normal image
            mOpenedItemPath = null;
        } else if (mLoadingState != LOADING_INIT) {
            mLoadingState = LOADING_INIT;
            mHandler.removeMessages(MSG_SHOW_LOADING);
            mHandler.sendEmptyMessageDelayed(
                    MSG_SHOW_LOADING, DELAY_SHOW_LOADING);
        }
    }

    public void notifyModelInvalidated() {
        if (MtkLog.DBG) {
            MtkLog.d(TAG, "notifyModelInvalidated");
        }
        if (mModel == null) {
            updateScreenNailEntry(ENTRY_PREVIOUS, null);
            updateScreenNailEntry(ENTRY_NEXT, null);
        } else {
            updateScreenNailEntry(ENTRY_PREVIOUS, mModel.getPreviousImage());
            updateScreenNailEntry(ENTRY_NEXT, mModel.getNextImage());
        }
        layoutScreenNails();

        if (mModel == null) {
            mTileView.notifyModelInvalidated();
            mImageRotation = 0;
            mPositionController.setImageSize(0, 0);
            updateLoadingState();

            //added for stereo display feature
            if (mIsStereoDisplaySupported) {
                mFirstTileView.notifyModelInvalidated();
                mSecondTileView.notifyModelInvalidated();
            }
        } else {
            notifyImageInvalidated(0);
        }
    }

    @Override
    protected boolean onTouch(MotionEvent event) {
        mGestureDetector.onTouchEvent(event);
        mScaleDetector.onTouchEvent(event);
        mDownUpDetector.onTouchEvent(event);
        return true;
    }

    @Override
    protected void onLayout(
            boolean changeSize, int left, int top, int right, int bottom) {
        mTileView.layout(left, top, right, bottom);
        mEdgeView.layout(left, top, right, bottom);
        if (changeSize) {
            mPositionController.setViewSize(getWidth(), getHeight());
            for (ScreenNailEntry entry : mScreenNails) {
                entry.updateDrawingSize();
            }
        }
        //added for stereo display feature
        if (mIsStereoDisplaySupported) {
            mFirstTileView.layout(left, top, right, bottom);
            mSecondTileView.layout(left, top, right, bottom);
        }
    }

    private static int gapToSide(int imageWidth, int viewWidth) {
        return Math.max(0, (viewWidth - imageWidth) / 2);
    }

    /*
     * Here is how we layout the screen nails
     *
     *  previous            current           next
     *  ___________       ________________     __________
     * |  _______  |     |   __________   |   |  ______  |
     * | |       | |     |  |   right->|  |   | |      | |
     * | |       |<-------->|<--left   |  |   | |      | |
     * | |_______| |  |  |  |__________|  |   | |______| |
     * |___________|  |  |________________|   |__________|
     *                |  <--> gapToSide()
     *                |
     * IMAGE_GAP + Max(previous.gapToSide(), current.gapToSide)
     */
    private void layoutScreenNails() {
        int width = getWidth();
        int height = getHeight();

        // Use the image width in AC, since we may fake the size if the
        // image is unavailable
        RectF bounds = mPositionController.getImageBounds();
        int left = Math.round(bounds.left);
        int right = Math.round(bounds.right);
        int gap = gapToSide(right - left, width);

        // layout the previous image
        ScreenNailEntry entry = mScreenNails[ENTRY_PREVIOUS];

        if (entry.isEnabled()) {
            entry.layoutRightEdgeAt(left - (
                    IMAGE_GAP + Math.max(gap, entry.gapToSide())));
        }

        // layout the next image
        entry = mScreenNails[ENTRY_NEXT];
        if (entry.isEnabled()) {
            entry.layoutLeftEdgeAt(right + (
                    IMAGE_GAP + Math.max(gap, entry.gapToSide())));
        }
    }

    @Override
    protected void render(GLCanvas canvas) {
        PositionController p = mPositionController;

        // Draw the current photo
        if (mLoadingState == LOADING_COMPLETE) {
            super.render(canvas);
        }

        // Draw the previous and the next photo
        if (mTransitionMode != TRANS_SLIDE_IN_LEFT
                && mTransitionMode != TRANS_SLIDE_IN_RIGHT
                && mTransitionMode != TRANS_OPEN_ANIMATION) {
            ScreenNailEntry prevNail = mScreenNails[ENTRY_PREVIOUS];
            ScreenNailEntry nextNail = mScreenNails[ENTRY_NEXT];

            if (prevNail.mVisible) prevNail.draw(canvas);
            if (nextNail.mVisible) nextNail.draw(canvas);
        }

        // Draw the progress spinner and the text below it
        //
        // (x, y) is where we put the center of the spinner.
        // s is the size of the video play icon, and we use s to layout text
        // because we want to keep the text at the same place when the video
        // play icon is shown instead of the spinner.
        int w = getWidth();
        int h = getHeight();
        int x = Math.round(mPositionController.getImageBounds().centerX());
        int y = h / 2;
        int s = Math.min(getWidth(), getHeight()) / 6;

        if (mLoadingState == LOADING_TIMEOUT) {
            StringTexture m = mLoadingText;
            ProgressSpinner r = mLoadingSpinner;
            r.draw(canvas, x - r.getWidth() / 2, y - r.getHeight() / 2);
            m.draw(canvas, x - m.getWidth() / 2, y + s / 2 + 5);
            invalidate(); // we need to keep the spinner rotating
        } else if (mLoadingState == LOADING_FAIL) {
            StringTexture m = mNoThumbnailText;
            m.draw(canvas, x - m.getWidth() / 2, y + s / 2 + 5);
        }

        // Draw the video play icon (in the place where the spinner was)
        if (mShowVideoPlayIcon
                && mLoadingState != LOADING_INIT
                && mLoadingState != LOADING_TIMEOUT) {
            mVideoPlayIcon.draw(canvas, x - s / 2, y - s / 2, s, s);
        }

        // Draw the mpo view icon (in the place where the spinner was)
        if (MediatekFeature.isMpoSupported()
                && mShowMpoViewIcon
                && mLoadingState != LOADING_INIT
                && mLoadingState != LOADING_TIMEOUT) {
            mMpoViewIcon.draw(canvas, x - s / 2, y - s / 2, s, s);
        }

        // if we are in stereo mode, after we've drawn the left frame,
        // we don't advanceAnimation to make right frame neck and neck
        // with left frame.
        if (null != getGLRoot() && getGLRoot().getStereoMode() && 
            getGLRoot().getStereoPassId() == 
            MediatekFeature.STEREO_DISPLAY_LEFT_PASS) {
            return;
        }

        if (mPositionController.advanceAnimation()) invalidate();
    }

    private void stopCurrentSwipingIfNeeded() {
        // Enable fast sweeping
        if (mTransitionMode == TRANS_SWITCH_NEXT) {
            mTransitionMode = TRANS_NONE;
            mPositionController.stopAnimation();
            switchToNextImage();
        } else if (mTransitionMode == TRANS_SWITCH_PREVIOUS) {
            mTransitionMode = TRANS_NONE;
            mPositionController.stopAnimation();
            switchToPreviousImage();
        }
    }

    private boolean swipeImages(float velocity) {
        if (mTransitionMode != TRANS_NONE
                && mTransitionMode != TRANS_SWITCH_NEXT
                && mTransitionMode != TRANS_SWITCH_PREVIOUS) return false;

        ScreenNailEntry next = mScreenNails[ENTRY_NEXT];
        ScreenNailEntry prev = mScreenNails[ENTRY_PREVIOUS];

        int width = getWidth();

        // If we are at the edge of the current photo and the sweeping velocity
        // exceeds the threshold, switch to next / previous image.
        PositionController controller = mPositionController;
        boolean isMinimal = controller.isAtMinimalScale();

        if (velocity < -SWIPE_THRESHOLD &&
                (isMinimal || controller.isAtRightEdge())) {
            stopCurrentSwipingIfNeeded();
            if (next.isEnabled()) {
                mTransitionMode = TRANS_SWITCH_NEXT;
                controller.startHorizontalSlide(next.mOffsetX - width / 2);
                return true;
            }
        } else if (velocity > SWIPE_THRESHOLD &&
                (isMinimal || controller.isAtLeftEdge())) {
            stopCurrentSwipingIfNeeded();
            if (prev.isEnabled()) {
                mTransitionMode = TRANS_SWITCH_PREVIOUS;
                controller.startHorizontalSlide(prev.mOffsetX - width / 2);
                return true;
            }
        }

        return false;
    }

    public boolean snapToNeighborImage() {
        if (mTransitionMode != TRANS_NONE) return false;

        ScreenNailEntry next = mScreenNails[ENTRY_NEXT];
        ScreenNailEntry prev = mScreenNails[ENTRY_PREVIOUS];

        int width = getWidth();
        PositionController controller = mPositionController;

        RectF bounds = controller.getImageBounds();
        int left = Math.round(bounds.left);
        int right = Math.round(bounds.right);
        int threshold = SWITCH_THRESHOLD + gapToSide(right - left, width);

        // If we have moved the picture a lot, switching.
        if (next.isEnabled() && threshold < width - right) {
            mTransitionMode = TRANS_SWITCH_NEXT;
            controller.startHorizontalSlide(next.mOffsetX - width / 2);
            return true;
        }
        if (prev.isEnabled() && threshold < left) {
            mTransitionMode = TRANS_SWITCH_PREVIOUS;
            controller.startHorizontalSlide(prev.mOffsetX - width / 2);
            return true;
        }

        return false;
    }

    private boolean mIgnoreUpEvent = false;

    private class MyGestureListener
            extends GestureDetector.SimpleOnGestureListener {
        @Override
        public boolean onScroll(
                MotionEvent e1, MotionEvent e2, float dx, float dy) {
            if (mTransitionMode != TRANS_NONE) return true;

            ScreenNailEntry next = mScreenNails[ENTRY_NEXT];
            ScreenNailEntry prev = mScreenNails[ENTRY_PREVIOUS];

            mPositionController.startScroll(dx, dy, next.isEnabled(),
                    prev.isEnabled());
            return true;
        }

        /*
        @Override
        public boolean onSingleTapUp(MotionEvent e) {
            if (mPhotoTapListener != null) {
                mPhotoTapListener.onSingleTapUp((int) e.getX(), (int) e.getY());
            }
            return true;
        }
        */
        
        // we use onSingleTapConfirmed to avoid onSingleTapUp being fired during a double tap gesture,
        // since onSingleTapUp before onDoubleTap will cause action bar to show/hide,
        // and this might influence the performance of zoom in/zoom out.
        // trade-off: this tap event is delayed for 300ms comparing to onSingleTapUp,
        // so UI response will seem to be a little slower for single taps.
        @Override
        public boolean onSingleTapConfirmed(MotionEvent e) {
            if (mPhotoTapListener != null) {
                mPhotoTapListener.onSingleTapUp((int) e.getX(), (int) e.getY());
            }
            return true;
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
                float velocityY) {
            if (swipeImages(velocityX)) {
                mIgnoreUpEvent = true;
            } else if (mTransitionMode != TRANS_NONE) {
                // do nothing
            } else if (mPositionController.fling(velocityX, velocityY)) {
                mIgnoreUpEvent = true;
            }
            return true;
        }

        @Override
        public boolean onDoubleTap(MotionEvent e) {
            if (mConvMode) {
                return true;
            }

            if (mTransitionMode != TRANS_NONE) return true;
            PositionController controller = mPositionController;
            float scale = controller.getCurrentScale();
            // onDoubleTap happened on the second ACTION_DOWN.
            // We need to ignore the next UP event.
            mIgnoreUpEvent = true;
            //for video/mpo, no scale/zoom is allowed temporarily
            if (mShowVideoPlayIcon || mShowMpoViewIcon) return true;

            //if (scale <= 1.0f || controller.isAtMinimalScale()) {
            //    controller.zoomIn(
            //            e.getX(), e.getY(), Math.max(1.5f, scale * 1.5f));
            //} else {
            //    controller.resetToFullView();
            //}

            // M: new zoom behavior
            if (controller.isInInitRate()) {
                //
                float zoomRate = controller.getSuggestZoomRate();
                if (scale >= zoomRate) {
                    zoomRate = controller.getSuggestLargerZoomRate();
                }
                controller.zoomIn(e.getX(), e.getY(), zoomRate);
            } else {
                controller.resetToFullView();
            }
            return true;
        }
    }

    private class MyScaleListener
            extends ScaleGestureDetector.SimpleOnScaleGestureListener {

        @Override
        public boolean onScale(ScaleGestureDetector detector) {
            if (mConvMode) {
                return true;
            }

            float scale = detector.getScaleFactor();
            if (Float.isNaN(scale) || Float.isInfinite(scale)
                    || mTransitionMode != TRANS_NONE) return true;
            //for video, no scale/zoom is allowed temporarily
            if (mShowVideoPlayIcon || mShowMpoViewIcon) return true;
            if (mStereoModeWhenScaled) {
                if (mPositionController.willScaleOutOf3DMode(scale)) {
                    if (mAtStereoMaxScaleWhenScaled) {
                        //try to show toast that display mode will switch to 2D
                        StereoHelper.tryToShowConvertTo2DMode((Context)mActivity);
                    } else {
                        return true;
                    }
                }
            }
            mPositionController.scaleBy(scale,
                    detector.getFocusX(), detector.getFocusY());
            return true;
        }

        @Override
        public boolean onScaleBegin(ScaleGestureDetector detector) {
            if (mConvMode) {
                return true;
            }

            if (mTransitionMode != TRANS_NONE) return false;
            //for video, no scale/zoom is allowed temporarily
            if (mShowVideoPlayIcon || mShowMpoViewIcon) return true;
            //for stereo image zoom behavior, record status when user begin to scale
            mStereoModeWhenScaled = mStereoModeAllowed && mStereoMode;
            mAtStereoMaxScaleWhenScaled = mPositionController.isAtMaxStereoScale();
            mPositionController.beginScale(
                detector.getFocusX(), detector.getFocusY());
            return true;
        }

        @Override
        public void onScaleEnd(ScaleGestureDetector detector) {
            if (mConvMode) {
                return;
            }

            //for video, no scale/zoom is allowed temporarily
            if (mShowVideoPlayIcon || mShowMpoViewIcon) return;
            mPositionController.endScale();
            snapToNeighborImage();
        }
    }

    public boolean jumpTo(int index) {
        if (mTransitionMode != TRANS_NONE) return false;
        mModel.jumpTo(index);
        return true;
    }

    public void notifyOnNewImage() {
        mPositionController.setImageSize(0, 0);
    }

    public void startSlideInAnimation(int direction) {
        PositionController a = mPositionController;
        a.stopAnimation();
        switch (direction) {
            case TRANS_SLIDE_IN_LEFT:
            case TRANS_SLIDE_IN_RIGHT: {
                mTransitionMode = direction;
                a.startSlideInAnimation(direction);
                break;
            }
            default: throw new IllegalArgumentException(String.valueOf(direction));
        }
    }

    private class MyDownUpListener implements DownUpDetector.DownUpListener {
        public void onDown(MotionEvent e) {
        }

        public void onUp(MotionEvent e) {
            mEdgeView.onRelease();

            if (mIgnoreUpEvent) {
                mIgnoreUpEvent = false;
                return;
            }
            if (!snapToNeighborImage() && mTransitionMode == TRANS_NONE) {
                mPositionController.up();
            }
        }
    }

    private void switchToNextImage() {
        // We update the texture here directly to prevent texture uploading.
        ScreenNailEntry prevNail = mScreenNails[ENTRY_PREVIOUS];
        ScreenNailEntry nextNail = mScreenNails[ENTRY_NEXT];
        mTileView.invalidateTiles();

        if (mIsStereoDisplaySupported) {
            mFirstTileView.invalidateTiles();
            mSecondTileView.invalidateTiles();
        }

        if (prevNail.mTexture != null) prevNail.mTexture.recycle();
        prevNail.mTexture = mTileView.mBackupImage;
        mTileView.mBackupImage = nextNail.mTexture;
        nextNail.mTexture = null;
        mModel.next();
    }

    private void switchToPreviousImage() {
        // We update the texture here directly to prevent texture uploading.
        ScreenNailEntry prevNail = mScreenNails[ENTRY_PREVIOUS];
        ScreenNailEntry nextNail = mScreenNails[ENTRY_NEXT];
        mTileView.invalidateTiles();

        if (mIsStereoDisplaySupported) {
            mFirstTileView.invalidateTiles();
            mSecondTileView.invalidateTiles();
        }

        if (nextNail.mTexture != null) nextNail.mTexture.recycle();
        nextNail.mTexture = mTileView.mBackupImage;
        mTileView.mBackupImage = prevNail.mTexture;
        nextNail.mTexture = null;
        mModel.previous();
    }

    public void notifyTransitionComplete() {
        mHandler.sendEmptyMessage(MSG_TRANSITION_COMPLETE);
    }

    private void onTransitionComplete() {
        int mode = mTransitionMode;
        mTransitionMode = TRANS_NONE;

        if (mModel == null) return;
        if (mode == TRANS_SWITCH_NEXT) {
            switchToNextImage();
        } else if (mode == TRANS_SWITCH_PREVIOUS) {
            switchToPreviousImage();
        }

        //call PositionController to update stereo status
        mPositionController.checkStereoMode();
    }

    public boolean isDown() {
        return mDownUpDetector.isDown();
    }

    public static interface Model extends TileImageView.Model {
        public void next();
        public void previous();
        public void jumpTo(int index);
        public int getImageRotation();

        // Return null if the specified image is unavailable.
        public ImageData getNextImage();
        public ImageData getPreviousImage();
        //added for DRM
        public boolean showDrmMicroThumb();
        //added for CMCC
        public boolean suggestFullScreen();
    }

    public static class ImageData {
        public int rotation;
        public Bitmap bitmap;

        public ImageData(Bitmap bitmap, int rotation) {
            this.bitmap = bitmap;
            this.rotation = rotation;
        }

        //added to support draw DRM icons
        //for FL drm, image behaves as normal picture.
        //for SD or CD drm, media in ImageData should be displayed
        //as DRM micro thumb, and an extra icon drawn onto it.
        //Note: for SD or CD drm, it will never enter consumed mode
        //in the ImageData structure.
        public boolean showDrmMicroThumb;
        public int subType;//no need ?
        //added for CMCC feature
        public int originWidth;
        public int originHeight;
        public boolean suggestFullScreen;

        public ImageData(Bitmap bitmap, int rotation, boolean showDrmMicroThumb,
                         int subType) {
            this(bitmap, rotation);
            //added for DRM
            this.showDrmMicroThumb = showDrmMicroThumb;
            this.subType = subType;//no need ?
        }
    }

    private static int getRotated(int degree, int original, int theother) {
        return ((degree / 90) & 1) == 0 ? original : theother;
    }

    private class ScreenNailEntry {
        private boolean mVisible;
        private boolean mEnabled;

        private int mRotation;
        private int mDrawWidth;
        private int mDrawHeight;
        private int mOffsetX;

        private BitmapTexture mTexture;

        //added to support drm
        public boolean showDrmMicroThumb;
        public int subType;//no need ?
        //added for CMCC feature
        public int originWidth;
        public int originHeight;
        public boolean suggestFullScreen;
        //added for stereo convergence that helps to decide if we can
        //switch to prev/next image
        public boolean mAllowed = true;

        public void set(boolean enabled, Bitmap bitmap, int rotation,
                        boolean showDrmMicroThumb, int subType) {
            this.showDrmMicroThumb = showDrmMicroThumb;
            this.subType = subType;//no need?

            set(enabled, bitmap, rotation);
        }

        public void set(boolean enabled, Bitmap bitmap, int rotation) {
            mEnabled = enabled;
            mRotation = rotation;
            if (bitmap == null) {
                if (mTexture != null) mTexture.recycle();
                mTexture = null;
            } else {
                if (mTexture != null) {
                    if (mTexture.getBitmap() != bitmap) {
                        mTexture.recycle();
                        mTexture = new BitmapTexture(bitmap);
                    }
                } else {
                    mTexture = new BitmapTexture(bitmap);
                }
                updateDrawingSize();
            }
        }

        public void layoutRightEdgeAt(int x) {
            mVisible = x > 0;
            mOffsetX = x - getRotated(
                    mRotation, mDrawWidth, mDrawHeight) / 2;
        }

        public void layoutLeftEdgeAt(int x) {
            mVisible = x < getWidth();
            mOffsetX = x + getRotated(
                    mRotation, mDrawWidth, mDrawHeight) / 2;
        }

        public int gapToSide() {
            return ((mRotation / 90) & 1) != 0
                    ? PhotoView.gapToSide(mDrawHeight, getWidth())
                    : PhotoView.gapToSide(mDrawWidth, getWidth());
        }

        public void updateDrawingSize() {
            if (mTexture == null) return;

            int width = mTexture.getWidth();
            int height = mTexture.getHeight();

            if (MediatekFeature.isCMCC() &&
                0 != originWidth && 0 != originHeight) {
                width = originWidth;
                height = originHeight;
            }

            // Calculate the initial scale that will used by PositionController
            // (usually fit-to-screen)
            float s = ((mRotation / 90) & 0x01) == 0
                    ? mPositionController.getMinimalScale(width, height, suggestFullScreen)
                    : mPositionController.getMinimalScale(height, width, suggestFullScreen);

            if (showDrmMicroThumb) {
                mDrawWidth = DrmHelper.getDrmMicroThumbDim((Activity) mActivity);
                mDrawHeight = mDrawWidth;
            } else {
                mDrawWidth = Math.round(width * s);
                mDrawHeight = Math.round(height * s);
            }
        }

        public boolean isEnabled() {
            return mEnabled && mAllowed;
        }

        public void setAllowed(boolean allowed) {
            mAllowed = allowed;
        }

        public void draw(GLCanvas canvas) {
            int x = mOffsetX;
            int y = getHeight() / 2;

            if (mTexture != null) {
                if (mRotation != 0) {
                    canvas.save(GLCanvas.SAVE_FLAG_MATRIX);
                    canvas.translate(x, y, 0);
                    canvas.rotate(mRotation, 0, 0, 1); //mRotation
                    canvas.translate(-x, -y, 0);
                }
                mTexture.draw(canvas, x - mDrawWidth / 2, y - mDrawHeight / 2,
                        mDrawWidth, mDrawHeight);
                if (mRotation != 0) {
                    canvas.restore();
                }
            }
        }
    }

    public void pause() {
        mPositionController.skipAnimation();
        mTransitionMode = TRANS_NONE;
        mTileView.freeTextures();

        //added for stereo display feature
        if (mIsStereoDisplaySupported) {
            mFirstTileView.freeTextures();
            mSecondTileView.freeTextures();
        }

        for (ScreenNailEntry entry : mScreenNails) {
            entry.set(false, null, 0);
        }
    }

    public void resume() {
        mTileView.prepareTextures();

        //added for stereo display feature
        if (mIsStereoDisplaySupported) {
            mFirstTileView.prepareTextures();
            mSecondTileView.prepareTextures();
        }

        if (mIsStereoDisplaySupported && null != getGLRoot()) {
            getGLRoot().setStereoMode(mStereoModeAllowed && mStereoMode);
        }
    }

    public void setOpenedItem(Path itemPath) {
        mOpenedItemPath = itemPath;
    }

    public void showVideoPlayIcon(boolean show) {
        mShowVideoPlayIcon = show;
    }

    public void showMpoViewIcon(boolean show) {
        mShowMpoViewIcon = show;
    }

    // Returns the position saved by the previous page.
    public Position retrieveSavedPosition() {
        if (MtkLog.DBG) {
            MtkLog.i(TAG, "retrieveSavedPosition: open item path=" + mOpenedItemPath);
        }
        if (mOpenedItemPath != null) {
            Position position = PositionRepository
                    .getInstance(mActivity).get(Long.valueOf(
                    System.identityHashCode(mOpenedItemPath)));
            mOpenedItemPath = null;
            return position;
        }
        return null;
    }

    public void openAnimationStarted() {
        mTransitionMode = TRANS_OPEN_ANIMATION;
    }

    public boolean isInTransition() {
        return mTransitionMode != TRANS_NONE;
    }

    public void allowStereoMode(boolean stereoModeAllowed) {
        if (mStereoModeAllowed == stereoModeAllowed) return;
        mStereoModeAllowed = stereoModeAllowed;

        if (null == getGLRoot()) return;
        getGLRoot().setStereoMode(mStereoModeAllowed && mStereoMode);
        mStereoModeChangeListener.onChangedToStereoMode(mStereoModeAllowed && mStereoMode);
        invalidate();

    }

    public void setStereoMode(boolean stereoMode) {
        if (null == mModel) return;
        if (stereoMode && null == mModel.getSecondImage()) {
            //if second image is not loaded, do not display stereo
            stereoMode = false;
        }
        if (mStereoMode == stereoMode) return;
        mStereoMode = stereoMode;
        //we should synchronize ?
        if (null == getGLRoot()) return;
        getGLRoot().setStereoMode(mStereoModeAllowed && mStereoMode);
        mStereoModeChangeListener.onChangedToStereoMode(mStereoModeAllowed && mStereoMode);
        invalidate();
    }

    public boolean getStereoMode() {
        return mStereoMode;
    }

    //return true if the picture is set to original zoomed state
    //return false if reset failed, possibly because there is an anmation
    //ongoing
    public boolean onResetZoomedState() {
        if (mTransitionMode != TRANS_NONE) return false;
        PositionController controller = mPositionController;

        if (controller.isInStereoRate()) {
            return true;
        }

        mIgnoreUpEvent = true;
        controller.resetToFullView();
        return true;
    }
    
    public void enterConvMode(boolean convMode) {
        mConvMode = convMode;
        allowPrevNextImage(!convMode);
    }

    public boolean onZoomToSuggestedScale() {
        if (mTransitionMode != TRANS_NONE) return false;
        PositionController controller = mPositionController;

        mIgnoreUpEvent = true;
        controller.resetToSuggestedScale();
        return true;
    }
    
    private void allowPrevNextImage(boolean allow) {
        ScreenNailEntry prev = mScreenNails[ENTRY_PREVIOUS];
        if (null != prev) {
            prev.setAllowed(allow);
        }
        ScreenNailEntry next = mScreenNails[ENTRY_NEXT];
        if (null != next) {
            next.setAllowed(allow);
        }
    }
}
